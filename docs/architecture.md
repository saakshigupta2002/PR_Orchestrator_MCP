# Architecture

This document describes the high‑level architecture of the **PR Orchestrator MCP**.  The goal of the MCP server is to provide a set of deterministic tools over a simple transport (stdio) that can be invoked by an orchestrating client, such as an LLM, to perform repository fixes.  The server enforces safety and secret management, and delegates reasoning and planning to the client.

## Components

### Server (entrypoint)

The entrypoint defined in `src/pr_orchestrator/server.py` implements a simple request/response loop.  It reads JSON‑encoded tool requests from standard input and writes JSON‑encoded responses to standard output.  Each request specifies a tool name and arguments; the server dispatches the call to the appropriate implementation in `src/pr_orchestrator/tools/`.

### Configuration

Configuration values are loaded from environment variables via the `dotenv` package.  They populate a `Config` object (see `config.py`) that is passed throughout the application.  Mandatory secrets (e.g. `GITHUB_TOKEN`) must be present in the `.env` file; otherwise the server refuses to start.

### Workspace

Workspace operations are implemented in `sandbox/`.  The server supports two modes: `code` (default) and `desktop`.  In code mode the server uses the [E2B code sandbox](https://github.com/e2b-dev/e2b) via its API to provision a fresh container with network access restricted to package registries and GitHub.  A `WorkspaceStore` keeps track of active workspaces and enforces time‑to‑live limits.

### Repository

Repository operations are implemented in `git/`.  They wrap `git` command‑line invocations via the `GitPython` library.  The workflow ensures that a fork exists (creating one if necessary), clones the fork into the workspace, adds the upstream remote, fetches the latest commits and checks out the appropriate branch.  Branch naming follows the strategy defined in the specification and avoids collisions by reusing or suffixing names.

### Editing

Editing tools in `tools/edit_tools.py` expose safe file operations: reading file contents, searching for text patterns, writing new files and applying unified diffs.  Patches are validated and redacted via the `policy/redaction.py` module to ensure secrets never leak into commits or logs.

### Quality Assurance

Quality tools live in `qa/`.  They provide functions to detect the project type, install dependencies, run tests, lint, type checks and formatting.  To maintain determinism, only specified commands are executed and timeouts are enforced.  Results are returned as structured JSON, including exit codes, pass/fail status and logs.

### GitHub Integration

GitHub operations in `github/` use the official REST API via the `requests` library.  Authentication is performed using a personal access token stored in `.env`.  The server can retrieve issues, find existing PRs for an issue, push commits to the fork and open a draft pull request on the upstream repository.  The PR body is generated using templates defined in `github/templates.py`.

### Approval Gate

Before any changes are pushed or a PR is opened, the client must call the `approval` tool implemented in `tools/approval_tools.py`.  This tool presents a summary, diff, checks and branch plan to a human reviewer (or mocks approval in automated tests) and returns whether the changes are approved.  If `approved` is false, the workflow is aborted.

### Artifacts and Telemetry

Artifacts such as diffs, metadata and logs are bundled into a zip archive by `artifacts/bundler.py`.  This archive is returned to the client along with the PR URL.  Telemetry such as run logs and workspace lifetimes are recorded by `telemetry/logger.py` and `telemetry/run_store.py` for troubleshooting and auditing.

## Sequence Diagram

1. **workspace_create** – The client requests a new workspace.  The server provisions an E2B container and returns a `workspace_id`.
2. **ensure_fork** – The server checks if the fork exists for the configured GitHub user; if not, it creates one.
3. **repo_clone** – Clone the fork into the workspace and fetch the upstream repository.
4. **repo_create_branch** – Determine the branch name based on the issue and create or reuse it.
5. **run_tests/run_lint/run_typecheck** – Establish a baseline by running tests on the base branch and capturing failures.
6. **apply_patch** – Apply edits generated by the client.  Loop until tests pass or the iteration limit is reached.
7. **request_approval** – Present the diff and evidence to a reviewer for approval.
8. **repo_push** – Push the branch to the fork.
9. **github_open_pr** – Open a draft PR against the upstream repository with the compiled evidence.

Refer to `docs/tool-spec.md` for details of each tool.